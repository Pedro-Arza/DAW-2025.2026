<!DOCTYPE html>
<html>
<head>
    <title>Pac-Man</title>
    <meta charset="UTF-8">
    <style>
        body {
            background-color: #00e1ff;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: 'Arial', sans-serif;
        }
        h1 {
            color: #FFFF00; /* Amarillo Pac-Man */
        }
        canvas {
            background-color: #000000;
            border: 2px solid #0000FF; /* Borde azul como en el original */
        }
        #info {
            margin-top: 20px;
            font-size: 1.5em;
        }
        a {
            margin-top: 20px;
            color: #ffffff;
            text-decoration: none;
            font-size: 1.2em;
            border: 1px solid #fff;
            padding: 10px;
            border-radius: 5px;
        }
        a:hover {
            background-color: #FFFF00;
            color: #ffffff;
        }
    </style>
</head>
<body>
    <h1>Pac-Man</h1>
    <canvas id="gameCanvas" width="448" height="496"></canvas>
    <div id="info">
        <span>Puntuación: <span id="score">0</span></span>
    </div>
    <a href="/">Volver a la página principal</a>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');

        const tileSize = 16;
        let score = 0;

        // Representación del mapa: 0 = vacío, 1 = pared, 2 = punto, 3 = superpunto
        const map = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,3,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,3,1],
            [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],
            [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,1,1,1,1,1],
            [0,0,0,0,0,1,2,1,1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,0,0,0,0,0],
            [1,1,1,1,1,1,2,1,1,0,1,1,1,0,0,1,1,1,0,1,1,2,1,1,1,1,1,1],
            [1,2,2,2,2,2,2,0,0,0,1,0,0,0,0,0,0,1,0,0,0,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,2,1,1,0,1,0,0,0,0,0,0,1,0,1,1,2,1,1,1,1,1,1],
            [0,0,0,0,0,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,0,0,0,0,0],
            [0,0,0,0,0,1,2,1,1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,0,0,0,0,0],
            [1,1,1,1,1,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,3,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,3,1],
            [1,2,2,2,1,1,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,1,1,2,2,2,1],
            [1,1,2,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,2,1,1],
            [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
            [1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
        
        // Clases
        class Player {
            constructor(x, y, speed) {
                this.x = x;
                this.y = y;
                this.speed = speed;
                this.radius = tileSize / 2 - 2;
                this.mouth = 0;
                this.direction = { x: 0, y: 0 };
                this.nextDirection = { x: 0, y: 0 };
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                const angle = Math.atan2(this.direction.y, this.direction.x);
                if (this.direction.x !== 0 || this.direction.y !== 0) {
                     ctx.rotate(angle);
                }

                ctx.fillStyle = 'yellow';
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, this.mouth, Math.PI * 2 - this.mouth);
                ctx.lineTo(0,0);
                ctx.fill();
                ctx.restore();
            }

            update() {
                this.mouth = Math.abs(Math.sin(Date.now() * 0.02)) * (Math.PI / 4);
                
                if(this.canMove(this.nextDirection)) {
                    this.direction = {...this.nextDirection};
                }
                
                if (this.canMove(this.direction)) {
                    this.x += this.direction.x * this.speed;
                    this.y += this.direction.y * this.speed;
                }
            }

            canMove(dir) {
                if (dir.x === 0 && dir.y === 0) return true;
                const nextX = this.x + dir.x * this.speed;
                const nextY = this.y + dir.y * this.speed;
                const gridX = Math.floor(nextX / tileSize);
                const gridY = Math.floor(nextY / tileSize);
                
                // Centrar la colisión
                const centerX = this.x + dir.x;
                const centerY = this.y + dir.y;
                
                for(let i = -1; i <= 1; i++) {
                    for(let j = -1; j <= 1; j++) {
                        const tileX = Math.floor((centerX + i * this.radius) / tileSize);
                        const tileY = Math.floor((centerY + j * this.radius) / tileSize);
                        if(map[tileY] && map[tileY][tileX] === 1){
                             return false;
                        }
                    }
                }
                return true;
            }
        }
        
        // Inicialización
        const player = new Player(tileSize * 1.5, tileSize * 1.5, 2);

        // Bucle del juego
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        function update() {
            player.update();
            eatPellets();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawMap();
            player.draw();
        }

        function drawMap() {
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[y].length; x++) {
                    if (map[y][x] === 1) { // Pared
                        ctx.fillStyle = 'blue';
                        ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    } else if (map[y][x] === 2) { // Punto
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(x * tileSize + tileSize / 2, y * tileSize + tileSize / 2, 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (map[y][x] === 3) { // Superpunto
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(x * tileSize + tileSize / 2, y * tileSize + tileSize / 2, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }
        
        function eatPellets() {
            const gridX = Math.floor(player.x / tileSize);
            const gridY = Math.floor(player.y / tileSize);

            if(map[gridY] && map[gridY][gridX] === 2) {
                map[gridY][gridX] = 0;
                score += 10;
                scoreElement.innerText = score;
            } else if (map[gridY] && map[gridY][gridX] === 3) {
                 map[gridY][gridX] = 0;
                score += 50;
                scoreElement.innerText = score;
                // Lógica para modo "power-up" (fantasmas vulnerables) iría aquí
            }
        }
        
        // Controles
        window.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp':
                    player.nextDirection = { x: 0, y: -1 };
                    break;
                case 'ArrowDown':
                    player.nextDirection = { x: 0, y: 1 };
                    break;
                case 'ArrowLeft':
                    player.nextDirection = { x: -1, y: 0 };
                    break;
                case 'ArrowRight':
                    player.nextDirection = { x: 1, y: 0 };
                    break;
            }
        });
        
        // Iniciar el juego
        gameLoop();
    </script>
</body>
</html>
